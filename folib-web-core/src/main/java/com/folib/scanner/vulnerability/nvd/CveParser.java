/*
 * Folib - [新一代AI制品仓库]
 * Copyright (C) 2025 bocloud.com.cn <folib@beyondcent.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * 本程序是自由软件：您可依据GNU通用公共许可证（GPL-3.0+）条款重新发布和修改，
 * 但禁止任何形式的商业售卖行为（包括但不限于：直接销售、捆绑销售、云服务商用）。
 *
 * This program is distributed WITHOUT ANY WARRANTY.
 * Commercial sale of this software is expressly prohibited.
 *
 * For license details, see: https://www.gnu.org/licenses/gpl-3.0.html
 * 商业授权咨询请联系：folib@beyondcent.com
 */
package com.folib.scanner.vulnerability.nvd;


import com.alibaba.fastjson.JSON;
import com.folib.scanner.vulnerability.ICweService;
import com.folib.scanner.vulnerability.SpringUtils;
import com.folib.scanner.vulnerability.model.*;
import com.folib.scanner.vulnerability.nvd.model.CpeMatch;
import com.folib.scanner.vulnerability.nvd.model.CveItem;
import com.folib.scanner.vulnerability.nvd.model.Node;
import com.folib.scanner.vulnerability.resolver.CweResolver;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.cvss.Cvss;
import us.springett.parsers.cpe.exceptions.CpeEncodingException;
import us.springett.parsers.cpe.exceptions.CpeParsingException;
import us.springett.parsers.cpe.values.Part;

import java.math.BigDecimal;
import java.sql.Date;
import java.time.OffsetDateTime;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.UUID;
import java.util.stream.Collectors;

public class CveParser {

    private static final Logger LOGGER = LoggerFactory.getLogger(CveParser.class);

    private enum Operator {
        AND,
        OR,
        NONE
    }

    public NvdDataModle fluxParseCveItem(CveItem cveItem) {

        final Vulnerability vulnerability = new Vulnerability();
        vulnerability.setSource(Vulnerability.Source.NVD);

        // CVE ID
        final var cve = cveItem.getCve();
        final var meta0 = cve.getMeta();
        vulnerability.setVulnId(meta0.getId());

        // CVE Published and Modified dates
        final String publishedDateString = cveItem.getPublishedDate();
        final String lastModifiedDateString = cveItem.getLastModifiedDate();
        try {
            if (StringUtils.isNotBlank(publishedDateString)) {
                vulnerability.setPublished(Date.from(OffsetDateTime.parse(publishedDateString).toInstant()));
            }
            if (StringUtils.isNotBlank(lastModifiedDateString)) {
                vulnerability.setUpdated(Date.from(OffsetDateTime.parse(lastModifiedDateString).toInstant()));
            }
        } catch (DateTimeParseException | NullPointerException | IllegalArgumentException e) {
            LOGGER.error("Unable to parse dates from NVD data feed", e);
        }

        // CVE Description
        final var descO = cve.getDescription();
        final var desc1 = descO.getDescriptionData();
        final StringBuilder descriptionBuilder = new StringBuilder();
        final StringBuilder zhDescriptionBuilder = new StringBuilder();
        for (final var desc2 : desc1) {
            if ("en".equals(desc2.getLang())) {
                // 对英文描述进行处理
                if (desc2.getZhValue() != null) {
                    zhDescriptionBuilder.append(desc2.getZhValue());
                } else {
                    descriptionBuilder.append(desc2.getValue());
                }
                // 在不是最后一个描述时添加换行
                if (!desc2.equals(desc1.get(desc1.size() - 1))) {
                    descriptionBuilder.append("\n\n");
                    zhDescriptionBuilder.append("\n\n");
                }
            }
        }

        vulnerability.setDescription(descriptionBuilder.toString());
        vulnerability.setZhDescription(zhDescriptionBuilder.toString());
        if (cveItem.getName() != null) {
            vulnerability.setName(cveItem.getName());
        }
        if (cveItem.getCnId() != null) {
            vulnerability.setCnvId(cveItem.getCnId());
        }
        // CVE Impact
        parseCveImpact(cveItem, vulnerability);

        // CWE
        final var prob0 = cve.getProblemType();
        final var prob1 = prob0.getData();
        ICweService cweService = SpringUtils.getBean(ICweService.class);
        for (final var prob2 : prob1) {
            final var prob3 = prob2.getDescription();
            for (final var prob4 : prob3) {
                if ("en".equals(prob4.getLang())) {
                    final String cweString = prob4.getValue();
                    if (cweString != null && cweString.startsWith("CWE-")) {
                        final Cwe cwe = CweResolver.getInstance().resolve(cweService, cweString);
                        if (cwe != null) {
                            vulnerability.addCwe(cwe);
                        } else {
                            LOGGER.warn("CWE " + cweString + " not found in  database. This could signify an issue with the NVD or with not having advanced knowledge of this specific CWE identifier.");
                        }
                    }
                }
            }
        }

        // References
        final var ref0 = cve.getReferences();
        final var ref1 = ref0.getReferenceData();
        //final StringBuilder sb = new StringBuilder();
        //for (final var ref2 : ref1) {
        //    if (ref2.getUrl() != null) {
        //        final String url = ref2.getUrl();
        //        sb.append("* [").append(url).append("](").append(url).append(")\n");
        //    }
        //}

        //final String references = sb.toString();
        if (!ref1.isEmpty()) {
            vulnerability.setReferences(JSON.toJSONString(ref1));
        }

        // CPE
        List<VulnerableSoftware> vsList = new ArrayList<>();
        final var configurations = cveItem.getConfigurations();
        final var nodes = configurations.getNodes();

        for (final var node : nodes) {
            final Operator nodeOperator = Operator.valueOf(node.getOperator() == null ? Operator.NONE.name() : node.getOperator().toUpperCase(Locale.ROOT));
            List<VulnerableSoftware> vulnerableSoftwareInNode;

            if (node.getChildren() != null && !node.getChildren().isEmpty()) {
                vulnerableSoftwareInNode = new ArrayList<>();
                for (final var child : node.getChildren()) {
                    vulnerableSoftwareInNode.addAll(parseCpes(child));
                }
            } else {
                vulnerableSoftwareInNode = parseCpes(node);
            }

            vsList.addAll(reconcile(vulnerableSoftwareInNode, nodeOperator));
        }

        NvdDataModle nvdDataModle = new NvdDataModle();
        nvdDataModle.setVulnerability(vulnerability);
        nvdDataModle.setVulnerableSoftwares(vsList);
        nvdDataModle.setAffectedVersionAttributions(toAffectedVersionAttributions(vulnerability, vsList, Vulnerability.Source.NVD));
        nvdDataModle.setVulnerableSoftwareVulnerabilitiess(toVulnerableSoftwareVulnerabilitiess(vulnerability, vsList));
        return nvdDataModle;
    }

    private void parseCveImpact(final CveItem cveItem, final Vulnerability vuln) {
        final var imp0 = cveItem.getImpact();
        final var imp1 = imp0.getBaseMetricV2();
        if (imp1 != null) {
            final var imp2 = imp1.getCvssV2();
            if (imp2 != null) {
                final Cvss cvss = Cvss.fromVector(imp2.getVectorString());
                vuln.setCvssV2Vector(cvss.getVector()); // normalize the vector but use the scores from the feed
                vuln.setCvssV2BaseScore(BigDecimal.valueOf(imp2.getBaseScore()));
            }
            vuln.setCvssV2ExploitabilitySubScore(BigDecimal.valueOf(imp1.getExploitabilityScore()));
            vuln.setCvssV2ImpactSubScore(BigDecimal.valueOf(imp1.getImpactScore()));
        }

        final var imp3 = imp0.getBaseMetricV3();
        if (imp3 != null) {
            final var imp4 = imp3.getCvssV3();
            if (imp4 != null) {
                final Cvss cvss = Cvss.fromVector(imp4.getVectorString());
                vuln.setCvssV3Vector(cvss.getVector()); // normalize the vector but use the scores from the feed
                vuln.setCvssV3BaseScore(BigDecimal.valueOf(imp4.getBaseScore()));
            }
            vuln.setCvssV3ExploitabilitySubScore(BigDecimal.valueOf(imp3.getExploitabilityScore()));
            vuln.setCvssV3ImpactSubScore(BigDecimal.valueOf(imp3.getImpactScore()));
        }
    }

    private List<VulnerableSoftware> parseCpes(final Node node) {
        final List<VulnerableSoftware> vsList = new ArrayList<>();
        final var cpeMatches = node.getCpeMatch();
        if (cpeMatches != null) {
            for (final var cpeMatch : cpeMatches) {
                if (cpeMatch.isVulnerable()) { // only parse the CPEs marked as vulnerable
                    final VulnerableSoftware vs = generateVulnerableSoftware(cpeMatch);
                    if (vs != null) {
                        vsList.add(vs);
                    }
                }
            }
        }
        return vsList;
    }

    private VulnerableSoftware generateVulnerableSoftware(final CpeMatch cpeMatch) {
        final String cpe23Uri = cpeMatch.getCpe23Uri();
        final String versionEndExcluding = cpeMatch.getVersionEndExcluding();
        final String versionEndIncluding = cpeMatch.getVersionEndIncluding();
        final String versionStartExcluding = cpeMatch.getVersionStartExcluding();
        final String versionStartIncluding = cpeMatch.getVersionStartIncluding();

        VulnerableSoftware vs = null;

        try {
            vs = ModelConverter.convertCpe23UriToVulnerableSoftware(cpe23Uri);
            vs.setVulnerable(cpeMatch.isVulnerable());
            vs.setVersionEndExcluding(versionEndExcluding);
            vs.setVersionEndIncluding(versionEndIncluding);
            vs.setVersionStartExcluding(versionStartExcluding);
            vs.setVersionStartIncluding(versionStartIncluding);
            //Event.dispatch(new IndexEvent(IndexEvent.Action.CREATE, qm.detach(VulnerableSoftware.class, vs.getId())));
            return vs;
        } catch (CpeParsingException | CpeEncodingException e) {
            LOGGER.warn("An error occurred while parsing: " + cpe23Uri + " - The CPE is invalid and will be discarded.");
        }
        return null;
    }

    private List<VulnerableSoftware> reconcile(List<VulnerableSoftware> vulnerableSoftwareList, final Operator nodeOperator) {
        if (Operator.AND != nodeOperator) {
            return vulnerableSoftwareList;
        }

        final List<VulnerableSoftware> appPartList = new ArrayList<>();
        final List<VulnerableSoftware> osPartList = new ArrayList<>();

        for (VulnerableSoftware vulnerableSoftware : vulnerableSoftwareList) {
            if (vulnerableSoftware.getCpe23() != null) {
                if (Part.OPERATING_SYSTEM.getAbbreviation().equals(vulnerableSoftware.getPart())) {
                    osPartList.add(vulnerableSoftware);
                } else if (Part.APPLICATION.getAbbreviation().equals(vulnerableSoftware.getPart())) {
                    appPartList.add(vulnerableSoftware);
                }
            }
        }

        return (!osPartList.isEmpty() && !appPartList.isEmpty()) ? appPartList : vulnerableSoftwareList;
    }

    public List<AffectedVersionAttribution> toAffectedVersionAttributions(Vulnerability vulnerability, List<VulnerableSoftware> vsList , Vulnerability.Source source){
        return vsList.stream().map(vs -> {
            AffectedVersionAttribution  attribution = new AffectedVersionAttribution(source, vulnerability, vs);
            attribution.setUuid(UUID.randomUUID().toString());
            return attribution;
        }).collect(Collectors.toList());
    }

    public List<VulnerableSoftwareVulnerabilities> toVulnerableSoftwareVulnerabilitiess(Vulnerability vulnerability, List<VulnerableSoftware> vsList) {
        return vsList.stream().map(vs -> {
            return new VulnerableSoftwareVulnerabilities(vulnerability.getVulnId(), vs.getCpe22());
        }).collect(Collectors.toList());
    }
}

