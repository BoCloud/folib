/*
 * Folib - [新一代AI制品仓库]
 * Copyright (C) 2025 bocloud.com.cn <folib@beyondcent.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * 本程序是自由软件：您可依据GNU通用公共许可证（GPL-3.0+）条款重新发布和修改，
 * 但禁止任何形式的商业售卖行为（包括但不限于：直接销售、捆绑销售、云服务商用）。
 *
 * This program is distributed WITHOUT ANY WARRANTY.
 * Commercial sale of this software is expressly prohibited.
 *
 * For license details, see: https://www.gnu.org/licenses/gpl-3.0.html
 * 商业授权咨询请联系：folib@beyondcent.com
 */
package com.folib.scanner.vulnerability.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.lang3.tuple.Pair;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VulnerabilityAlias implements Serializable {

    private long id;

    private String internalId;

    private String cveId;

    private String ghsaId;

    private String sonatypeId;

    private String osvId;

    private String snykId;

    private String gsdId;

    private String vulnDbId;

    private String uuid;

    private String getBySource(final Vulnerability.Source source) {
        String result = null;
        switch (source) {
            case GITHUB:
                result = getGhsaId();
                break;
            case INTERNAL:
                result = getInternalId();
                break;
            case NVD:
                result = getCveId();
                break;
            case OSSINDEX:
                result = getSonatypeId();
                break;
            case OSV:
                result = getOsvId();
                break;
            case SNYK:
                result = getSnykId();
                break;
            case VULNDB:
                result = getVulnDbId();
                break;
            default:
                result = null;
                break;
        }
        return result;
    }

    @JsonIgnore
    public Map<Vulnerability.Source, String> getAllBySource() {
        return Arrays.stream(Vulnerability.Source.values())
                .map(source -> Pair.of(source, getBySource(source)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));
    }

    public void copyFieldsFrom(VulnerabilityAlias other) {
        // Check if each of the fields are null. We don't want to overwrite where only partial information is known, with nulls.
        cveId = firstNonNull(other.cveId, cveId);
        sonatypeId = firstNonNull(other.sonatypeId, sonatypeId);
        ghsaId = firstNonNull(other.ghsaId, ghsaId);
        osvId = firstNonNull(other.osvId, osvId);
        snykId = firstNonNull(other.snykId, snykId);
        gsdId = firstNonNull(other.gsdId, gsdId);
        vulnDbId = firstNonNull(other.vulnDbId, vulnDbId);
        internalId = firstNonNull(other.internalId, internalId);
    }

    private static String firstNonNull(String first, String second) {
        return first != null ? first : second;
    }

    /**
     * Compute how many vulnerability identifiers of this {@link VulnerabilityAlias}
     * match with those of a given other {@link VulnerabilityAlias}.
     * <p>
     * Identifiers are considered to be matches when they are equal but not {@code null}.
     *
     * @param other The {@link VulnerabilityAlias} to compute matches with
     * @return Number of matching identifiers
     */
    public int computeMatches(final VulnerabilityAlias other) {
        var matches = 0;

        if (this.getCveId() != null && this.getCveId().equals(other.getCveId())) {
            matches++;
        }
        if (this.getGhsaId() != null && this.getGhsaId().equals(other.getGhsaId())) {
            matches++;
        }
        if (this.getGsdId() != null && this.getGsdId().equals(other.getGsdId())) {
            matches++;
        }
        if (this.getOsvId() != null && this.getOsvId().equals(other.getOsvId())) {
            matches++;
        }
        if (this.getSnykId() != null && this.getSnykId().equals(other.getSnykId())) {
            matches++;
        }
        if (this.getSonatypeId() != null && this.getSonatypeId().equals(other.getSonatypeId())) {
            matches++;
        }
        if (this.getVulnDbId() != null && this.getVulnDbId().equals(other.getVulnDbId())) {
            matches++;
        }

        return matches;
    }

    @Override
    public String toString() {
        return "VulnerabilityAlias{" +
                "id=" + id +
                ", internalId='" + internalId + '\'' +
                ", cveId='" + cveId + '\'' +
                ", ghsaId='" + ghsaId + '\'' +
                ", sonatypeId='" + sonatypeId + '\'' +
                ", osvId='" + osvId + '\'' +
                ", snykId='" + snykId + '\'' +
                ", gsdId='" + gsdId + '\'' +
                ", vulnDbId='" + vulnDbId + '\'' +
                ", uuid=" + uuid +
                '}';
    }

}
