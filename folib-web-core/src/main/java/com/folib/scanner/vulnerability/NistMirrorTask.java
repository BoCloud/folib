/*
 * Folib - [新一代AI制品仓库]
 * Copyright (C) 2025 bocloud.com.cn <folib@beyondcent.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * 本程序是自由软件：您可依据GNU通用公共许可证（GPL-3.0+）条款重新发布和修改，
 * 但禁止任何形式的商业售卖行为（包括但不限于：直接销售、捆绑销售、云服务商用）。
 *
 * This program is distributed WITHOUT ANY WARRANTY.
 * Commercial sale of this software is expressly prohibited.
 *
 * For license details, see: https://www.gnu.org/licenses/gpl-3.0.html
 * 商业授权咨询请联系：folib@beyondcent.com
 */
package com.folib.scanner.vulnerability;

import com.folib.scanner.vulnerability.nvd.CweImporter;
import com.folib.scanner.vulnerability.nvd.NvdParser;
import lombok.Data;
import org.apache.commons.io.IOUtils;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpStatus;
import org.apache.http.StatusLine;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpUriRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Flux;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.zip.GZIPInputStream;

public class NistMirrorTask {

    private static final Logger LOGGER = LoggerFactory.getLogger(NistMirrorTask.class);

    private enum ResourceType {
        CVE_YEAR_DATA,
        CVE_MODIFIED_DATA,
        CVE_META,
        CPE,
        CWE,
        NONE // DO NOT PARSE THIS TYPE
    }

    //todo
    public static final String NVD_MIRROR_DIR = SpringUtils.getProperty("folib.vault");
    private static final String CVE_JSON_11_MODIFIED_URL = "/json/cve/1.1/nvdcve-1.1-modified.json.gz";
    private static final String CVE_JSON_11_BASE_URL = "/json/cve/1.1/nvdcve-1.1-%d.json.gz";
    private static final String CVE_JSON_11_MODIFIED_META = "/json/cve/1.1/nvdcve-1.1-modified.meta";
    private static final String CVE_JSON_11_BASE_META = "/json/cve/1.1/nvdcve-1.1-%d.meta";
    private static final int START_YEAR = 2002;
    private final int endYear = Calendar.getInstance().get(Calendar.YEAR);
    private boolean isEnabled;
    private String nvdFeedsUrl="https://nvd.nist.gov/feeds";
    private String outputDir;
    private long metricParseTime;
    private long metricDownloadTime;

    public void inform() throws Exception {
        new CweImporter().processCweDefinitions();
        final long start = System.currentTimeMillis();
        LOGGER.info("Starting NIST mirroring task");
        Path mirrorPath = Paths.get(NVD_MIRROR_DIR+"/nvd");
        setOutputDir(mirrorPath.toString());
        fluxAllFiles();
        final long end = System.currentTimeMillis();
        LOGGER.info("NIST mirroring complete");
        LOGGER.info("Time spent (d/l):   " + metricDownloadTime + "ms");
        LOGGER.info("Time spent (parse): " + metricParseTime + "ms");
        LOGGER.info("Time spent (total): " + (end - start) + "ms");
    }

    private void setOutputDir(final String outputDirPath) throws IOException {
        Path outputDir = Path.of(outputDirPath);
        if (!Files.exists(outputDir)) {
            Files.createDirectories(outputDir);
            LOGGER.info("Mirrored data directory created successfully");
        }
        this.outputDir = outputDir.toString();
    }

    @Data
    public static class NvdModel {
        private String url;
        private String fileName;
        private ResourceType resourceType;

        public NvdModel() {
        };

        public NvdModel(String url, ResourceType resourceType, String fileName) {
            this.url = url;
            this.resourceType = resourceType;
            this.fileName = fileName;
        }
    }

    private void fluxAllFiles() {
        final Date currentDate = new Date();
        LOGGER.info("Downloading files at " + currentDate);
        List<NvdModel> urls = getAllUrls();
        LOGGER.info("Downloading files size " + urls.size());
        Flux.fromIterable(urls)
                .map(url -> {
                    String fileName = fluxDoDownload(url.url, url.resourceType);
                    url.setFileName(fileName);
                    LOGGER.info("下载 结束  " + url.url);
                    return url;
                }).map(url -> {
                    fulxUncompress(url.fileName, url.resourceType);
                    if (url.fileName != null) {
                        LOGGER.info("解析 结束" + url.fileName);
                    }
                    return url;
                }).subscribe(url -> {
                    if (url.fileName != null) {
                        LOGGER.info("持久化 结束" + url.fileName);
                    }
                });
    }

    public List<NvdModel> getAllUrls() {
        List<NvdModel> urls = new ArrayList<NvdModel>();
        urls.add(new NvdModel(this.nvdFeedsUrl + CVE_JSON_11_MODIFIED_URL, ResourceType.CVE_MODIFIED_DATA, null));
        urls.add(new NvdModel(this.nvdFeedsUrl + CVE_JSON_11_MODIFIED_META, ResourceType.CVE_META, null));
        for (int i = endYear; i >= START_YEAR; i--) {
            // Download JSON 1.1 year feeds in reverse order
            final String json11BaseUrl = this.nvdFeedsUrl + CVE_JSON_11_BASE_URL.replace("%d", String.valueOf(i));
            final String cve11BaseMetaUrl = this.nvdFeedsUrl + CVE_JSON_11_BASE_META.replace("%d", String.valueOf(i));
            urls.add(new NvdModel(json11BaseUrl, ResourceType.CVE_YEAR_DATA, null));
            urls.add(new NvdModel(cve11BaseMetaUrl, ResourceType.CVE_META, null));
        }
        return urls;
    }


    private String fluxDoDownload(final String urlString, final ResourceType resourceType) {
        Path filePath;
        String filename = null;
        try {
            final URL url = new URL(urlString);
            filename = url.getFile();
            filename = filename.substring(filename.lastIndexOf('/') + 1);
            filePath= Paths.get(outputDir, filename);
            if (Files.exists(filePath)) {
                long modificationTime = 0;

                Path timestampFilePath = Paths.get(outputDir, filename + ".ts");
                if (Files.exists(timestampFilePath) && Files.size(timestampFilePath)  > 0) {
                    String text = Files.readString(timestampFilePath);
                    modificationTime = Long.parseLong(text);
                }

                //有效期30天
                if (System.currentTimeMillis() < ((86400000L * 30) + modificationTime)) {
                    if (ResourceType.CVE_YEAR_DATA == resourceType) {
                        LOGGER.info("Retrieval of " + filename + " not necessary. Will use modified feed for updates.");
                        return filename; //
                    } else if (ResourceType.CVE_META == resourceType) {
                        return filename; // no need to log
                    } else if (ResourceType.CVE_MODIFIED_DATA == resourceType) {
                        final long fileSize = checkHead(urlString);
                        if (Files.size(filePath) == fileSize) {
                            LOGGER.info("Using cached version of " + filename);
                            return filename; //
                        }
                    }
                }
            }
            final long start = System.currentTimeMillis();
            LOGGER.info("Initiating download of " + url.toExternalForm());
            final HttpUriRequest request = new HttpGet(urlString);
            try (final CloseableHttpResponse response = HttpClientPool.getClient().execute(request)) {
                final StatusLine status = response.getStatusLine();
                final long end = System.currentTimeMillis();
                metricDownloadTime += end - start;
                if (status.getStatusCode() == HttpStatus.SC_OK) {
                    LOGGER.info("Downloading...");
                    Path tempPath = Files.createTempFile(filename, null);
                    try (InputStream in = response.getEntity().getContent()) {
                        Files.copy(in, tempPath, StandardCopyOption.REPLACE_EXISTING);
                        Files.copy(tempPath, filePath, StandardCopyOption.REPLACE_EXISTING);
                    }
                    Files.delete(tempPath);
                    if (ResourceType.CVE_YEAR_DATA == resourceType || ResourceType.CVE_MODIFIED_DATA == resourceType) {
                        // Sets the last modified date to 0. Upon a successful parse, it will be set back to its original date.
                        Path timestampFilePath = Paths.get(outputDir, filename + ".ts");
                        writeTimeStampFile(timestampFilePath, 0L);
                    }
                } else if (response.getStatusLine().getStatusCode() == 403) {
                    final String detailMessage = "This may occur if the NVD is throttling connections due to excessive load or repeated " +
                            "connections from the same IP address or as a result of firewall or proxy authentication failures";
                    LOGGER.warn("Unable to download - HTTP Response 403: " + status.getReasonPhrase());
                    LOGGER.warn(detailMessage);

                } else {
                    LOGGER.warn("Unable to download - HTTP Response " + status.getStatusCode() + ": " + status.getReasonPhrase());
                }
            }

        } catch (IOException e) {
            LOGGER.error("Download failed : " + e.getMessage());
        }
        return filename;
    }

    private void fulxUncompress(String fileName, final ResourceType resourceType) {
        if (fileName != null && fileName.endsWith(".gz")) {
            Path outputPath = Paths.get(String.valueOf(outputDir), fileName).toAbsolutePath();
            final Path uncompressedPath = Paths.get(String.valueOf(outputDir), fileName.replaceAll(".gz", ""));
            try (final var gzis = new GZIPInputStream(Files.newInputStream(outputPath));
                 final var out = Files.newOutputStream(uncompressedPath)) {
                LOGGER.info("Uncompressed " + outputPath.getFileName());
                IOUtils.copy(gzis, out);
            } catch (IOException ex) {
                LOGGER.error("An error occurred uncompressed NVD payload", ex);
            }

            final long start = System.currentTimeMillis();
            if (ResourceType.CVE_YEAR_DATA == resourceType || ResourceType.CVE_MODIFIED_DATA == resourceType) {
                final NvdParser parser = new NvdParser();
                parser.fluxParse(uncompressedPath);
                // Update modification time
                Path timestampPath = Paths.get(outputPath.toString()+ ".ts");
                writeTimeStampFile(timestampPath, start);
            }
            final long end = System.currentTimeMillis();
            metricParseTime += end - start;
        }
    }

    private long checkHead(final String cveUrl) {
        final HttpUriRequest request = new HttpHead(cveUrl);
        try (final CloseableHttpResponse response = HttpClientPool.getClient().execute(request)) {
            return Long.parseLong(response.getFirstHeader(HttpHeaders.CONTENT_LENGTH).getValue());
        } catch (IOException | NumberFormatException | NullPointerException e) {
            LOGGER.error("Failed to determine content length");
        }
        return 0;
    }

    private void writeTimeStampFile(final Path filePath, Long modificationTime) {
        try {
            Files.write(filePath, Long.toString(modificationTime).getBytes());
        } catch (IOException ex) {
            LOGGER.error("An error occurred writing time stamp file", ex);
        }
    }
}
