/*
 * Folib - [新一代AI制品仓库]
 * Copyright (C) 2025 bocloud.com.cn <folib@beyondcent.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * 本程序是自由软件：您可依据GNU通用公共许可证（GPL-3.0+）条款重新发布和修改，
 * 但禁止任何形式的商业售卖行为（包括但不限于：直接销售、捆绑销售、云服务商用）。
 *
 * This program is distributed WITHOUT ANY WARRANTY.
 * Commercial sale of this software is expressly prohibited.
 *
 * For license details, see: https://www.gnu.org/licenses/gpl-3.0.html
 * 商业授权咨询请联系：folib@beyondcent.com
 */
package com.folib.scanner.vulnerability.nvd;


import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.folib.entity.PropertiesEntity;
import com.folib.mapper.PropertiesMapper;
import com.folib.scanner.vulnerability.IAffectedVersionAttributionService;
import com.folib.scanner.vulnerability.IVulnerabilityService;
import com.folib.scanner.vulnerability.IVulnerableSoftwareService;
import com.folib.scanner.vulnerability.SpringUtils;
import com.folib.scanner.vulnerability.nvd.model.CveItem;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Flux;

import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public final class NvdParser {

    private static final Logger LOGGER = LoggerFactory.getLogger(NvdParser.class);
    private final ObjectMapper objectMapper = new ObjectMapper();

    public void fluxParse(final Path filePath) {
        List<NvdDataModle> result = new ArrayList<>();
        if (!filePath.getFileName().toString().endsWith(".json")) {
            return;
        }

        LOGGER.info("Parsing " + filePath.getFileName());

        try (final InputStream in = Files.newInputStream(filePath);
             final JsonParser jsonParser = objectMapper.treeAsTokens(objectMapper.readTree(in))) {
            jsonParser.nextToken(); // Position cursor at first token

            // 由于 JSON 源相当大，因此不要完全解析它们、
            // 而是 “流 ”过它们。逐个解析单个 CVE 项目
            // 逐个解析，这样可以更快地启动垃圾回收、
            // 保持较低的总体内存占用。
            JsonToken currentToken;
            while (jsonParser.nextToken() != JsonToken.END_OBJECT) {
                final String fieldName = jsonParser.getCurrentName();
                currentToken = jsonParser.nextToken();
                if ("CVE_Items".equals(fieldName)) {
                    CveParser cveParser = new CveParser();
                    if (currentToken == JsonToken.START_ARRAY) {
                        while (jsonParser.nextToken() != JsonToken.END_ARRAY) {
                            final ObjectNode cveItem = jsonParser.readValueAsTree();
                            CveItem cveItem1 = objectMapper.treeToValue(cveItem, CveItem.class);
                            result.add(cveParser.fluxParseCveItem(cveItem1));
                        }
                    } else {
                        jsonParser.skipChildren();
                    }
                } else {
                    jsonParser.skipChildren();
                }
            }
        } catch (Exception e) {
            LOGGER.error("An error occurred while parsing NVD JSON data", e);
        }
        LOGGER.info("fluxParse result size: " + result.size());
        IVulnerabilityService vulnerabilityService = SpringUtils.getBean(IVulnerabilityService.class);
        IVulnerableSoftwareService softwareService = SpringUtils.getBean(IVulnerableSoftwareService.class);
        IAffectedVersionAttributionService attributionService = SpringUtils.getBean(IAffectedVersionAttributionService.class);
        Flux.fromIterable(result).buffer(200)
                .map(nvdDataModleList -> {
                    try {
                        vulnerabilityService.insertOrUpdateBatch(nvdDataModleList.stream().map(NvdDataModle::getVulnerability).collect(Collectors.toList()));
                    } catch (Exception e) {
                        LOGGER.error("Error in vulnerabilityService.insertOrUpdateBatch", e);
                        throw e; // 重新抛出异常以便后续处理
                    }
                    return nvdDataModleList;
                }).map(nvdDataModleList -> {
                    try {
                        softwareService.insertOrUpdateBatch(nvdDataModleList.stream().map(NvdDataModle::getVulnerableSoftwares).flatMap(List::stream).collect(Collectors.toList()));
                    } catch (Exception e) {
                        LOGGER.error("Error in softwareService.insertOrUpdateBatch", e);
                        throw e;
                    }
                    return nvdDataModleList;
                }).map(nvdDataModleList -> {
                    try {
                        attributionService.insertOrUpdateBatch(nvdDataModleList.stream().map(NvdDataModle::getAffectedVersionAttributions).flatMap(List::stream).collect(Collectors.toList()));
                    } catch (Exception e) {
                        LOGGER.error("Error in attributionService.insertOrUpdateBatch", e);
                        throw e;
                    }
                    return nvdDataModleList;
                }).map(nvdDataModleList -> {
                    try {
                        vulnerabilityService.svInsertOrUpdateBatch(nvdDataModleList.stream().map(NvdDataModle::getVulnerableSoftwareVulnerabilitiess).flatMap(List::stream).collect(Collectors.toList()));
                    } catch (Exception e) {
                        LOGGER.error("Error in vulnerabilityService.svInsertOrUpdateBatch", e);
                        throw e;
                    }
                    return nvdDataModleList;
                }).onErrorResume(e -> {
                    LOGGER.error("Error occurred in Flux processing", e);
                    return Flux.empty(); // 或者根据业务需求返回一个默认值或执行其他操作
                }).subscribe();

        PropertiesMapper propertiesMapper = SpringUtils.getBean(PropertiesMapper.class);
        if(propertiesMapper.count(filePath.getFileName().toString())>0){
            propertiesMapper.insert(new PropertiesEntity(filePath.getFileName().toString(), Integer.toString(result.size())));
        }else {
            propertiesMapper.update(new PropertiesEntity(filePath.getFileName().toString(), Integer.toString(result.size())));
        }
    }
}

