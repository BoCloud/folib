/*
 * Folib - [新一代AI制品仓库]
 * Copyright (C) 2025 bocloud.com.cn <folib@beyondcent.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * 本程序是自由软件：您可依据GNU通用公共许可证（GPL-3.0+）条款重新发布和修改，
 * 但禁止任何形式的商业售卖行为（包括但不限于：直接销售、捆绑销售、云服务商用）。
 *
 * This program is distributed WITHOUT ANY WARRANTY.
 * Commercial sale of this software is expressly prohibited.
 *
 * For license details, see: https://www.gnu.org/licenses/gpl-3.0.html
 * 商业授权咨询请联系：folib@beyondcent.com
 */
package com.folib.services.impl;

import cn.hutool.core.date.DateUtil;
import cn.hutool.core.io.FileUtil;
import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.write.metadata.WriteSheet;
import com.alibaba.excel.write.metadata.fill.FillConfig;
import com.alibaba.fastjson.JSONObject;
import com.google.common.collect.Sets;
import com.folib.components.artifact.ArtifactComponent;
import com.folib.components.email.MailRequest;
import com.folib.components.email.SendMail;
import com.folib.configuration.ConfigurationManager;
import com.folib.configuration.ConfigurationUtils;
import com.folib.db.schema.Properties;
import com.folib.domain.Artifact;
import com.folib.domain.RepositoryInfo;
import com.folib.domain.Vulnerability;
import com.folib.domain.VulnerabilityArtifactDomain;
import com.folib.forms.vulnerability.RepositoryVulnerabilityStatisticsForm;
import com.folib.forms.vulnerability.VulnerabilityGraphForm;
import com.folib.forms.vulnerability.VulnerabilityTableForm;
import com.folib.gremlin.entity.vo.ArtifactVo;
import com.folib.mapper.FolibUserMapper;
import com.folib.providers.layout.DockerLayoutProvider;
import com.folib.repositories.ArtifactRepository;
import com.folib.repositories.VulnerabilityRepository;
import com.folib.scanner.common.msg.TableResultResponse;
import com.folib.scanner.common.util.Query;
import com.folib.scanner.enums.SeverityTypeEnum;
import com.folib.services.ConfigurationManagementService;
import com.folib.services.VulnerabilityService;
import com.folib.services.VulnerabilityWebService;
import com.folib.storage.repository.Repository;
import com.folib.storage.repository.RepositoryDto;
import com.folib.storage.repository.RepositoryTypeEnum;
import com.folib.users.service.RoleResourceRefService;
import com.folib.util.FileSizeConvertUtils;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.compress.utils.Lists;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import javax.inject.Inject;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

/**
 * @author veadan
 * @date 2022/10/10
 **/
@Slf4j
@Service
@Transactional
public class VulnerabilityWebServiceImpl implements VulnerabilityWebService {

    @Inject
    private VulnerabilityRepository vulnerabilityRepository;

    @Inject
    private ConfigurationManagementService configurationManagementService;

    @Inject
    private ArtifactRepository artifactRepository;

    @Inject
    private FolibUserMapper folibUserMapper;

    @Inject
    private RoleResourceRefService roleResourceRefService;

    @Inject
    private VulnerabilityService vulnerabilityService;

    @Inject
    private SendMail sendMail;

    @Inject
    private ArtifactComponent artifactComponent;

    @Value("${folib.temp}")
    private String tempPath;

    @Inject
    private ConfigurationManager configurationManager;

    @Override
    public TableResultResponse<VulnerabilityTableForm> queryVulnerabilityPage(Integer source, Query query, String vulnerabilityId,
                                                                              String storageId,
                                                                              String repositoryId, Integer dateSearchType) {
        Pageable pageable = null;
        int page = query.getPage(), limit = query.getLimit();
        if (page == 1) {
            pageable = PageRequest.of(page, limit).first();
        } else {
            pageable = PageRequest.of(page, limit).previous();
        }
        List<String> storageIdAndRepositoryIdList = getStorageIdAndRepositoryId(storageId, repositoryId);
        Page<Vulnerability> vulnerabilityPage = vulnerabilityRepository.queryVulnerabilityPage(pageable, vulnerabilityId, storageId, storageIdAndRepositoryIdList, dateSearchType);
        return new TableResultResponse<VulnerabilityTableForm>(vulnerabilityPage.getTotalElements(), transform(vulnerabilityPage));
    }

    @Override
    public TableResultResponse<VulnerabilityTableForm> queryVulnerabilityPageByArtifact(Integer page, Integer limit, String artifactPath, String searchKeyword) {
        Pageable pageable = null;
        if (Objects.isNull(page)) {
            page = 1;
        }
        if (Objects.isNull(limit)) {
            limit = 10;
        }
        if (page == 1) {
            pageable = PageRequest.of(page, limit).first();
        } else {
            pageable = PageRequest.of(page, limit).previous();
        }
        Page<Vulnerability> vulnerabilityPage = vulnerabilityRepository.queryVulnerabilityPageByArtifact(pageable, artifactPath, searchKeyword);
        return new TableResultResponse<VulnerabilityTableForm>(vulnerabilityPage.getTotalElements(), transform(vulnerabilityPage));
    }

    @Override
    public TableResultResponse<VulnerabilityTableForm> queryVulnerabilityPageByComponent(Integer page, Integer limit, String componentUuid, String searchKeyword) {
        Pageable pageable = null;
        if (Objects.isNull(page)) {
            page = 1;
        }
        if (Objects.isNull(limit)) {
            limit = 10;
        }
        if (page == 1) {
            pageable = PageRequest.of(page, limit).first();
        } else {
            pageable = PageRequest.of(page, limit).previous();
        }
        Page<Vulnerability> vulnerabilityPage = vulnerabilityRepository.queryVulnerabilityPageByComponent(pageable, componentUuid, searchKeyword);
        return new TableResultResponse<VulnerabilityTableForm>(vulnerabilityPage.getTotalElements(), transform(vulnerabilityPage));
    }

    private List<VulnerabilityTableForm> transform(Page<Vulnerability> vulnerabilityPage) {
        SimpleDateFormat df = DateUtil.newSimpleFormat("yyyy-MM-dd HH:mm:ss");
        return vulnerabilityPage.getContent().stream().map(vulnerability -> {
            VulnerabilityTableForm vulnerabilityTableForm = VulnerabilityTableForm.builder().white(0).black(0).build();
            BeanUtils.copyProperties(vulnerability, vulnerabilityTableForm);
            if (vulnerability.getCreated() != null) {
                String createdTime = DateUtil.format(Date.from(vulnerability.getCreated().atZone(ZoneId.of("Asia/Shanghai")).toOffsetDateTime().toInstant()), df);
                vulnerabilityTableForm.setCreated(createdTime);
            }
            if (vulnerability.getLastUpdated() != null) {
                String lastUpdatedTime = DateUtil.format(Date.from(vulnerability.getLastUpdated().atZone(ZoneId.systemDefault()).toInstant()), df);
                vulnerabilityTableForm.setLastUpdated(lastUpdatedTime);
            }
            return vulnerabilityTableForm;
        }).collect(Collectors.toList());
    }

    @Override
    public VulnerabilityGraphForm graphV1(String uuid, String storageId, String repositoryId) {
        VulnerabilityGraphForm vulnerabilityGraphForm = VulnerabilityGraphForm.builder().rate(BigDecimal.valueOf(1)).build();
        Optional<Vulnerability> vulnerabilityOptional = vulnerabilityRepository.findById(uuid);
        List<String> storageIdAndRepositoryIdList = getStorageIdAndRepositoryId(storageId, repositoryId);
        Page<Artifact> artifactPage = artifactRepository.findMatchingByVulnerabilityUuid(PageRequest.of(1, 1000).first(), uuid, null, storageIdAndRepositoryIdList, "");
        if (Objects.isNull(artifactPage) || CollectionUtils.isEmpty(artifactPage.getContent())) {
            return vulnerabilityGraphForm;
        }
        List<Artifact> artifactList = artifactPage.getContent();
        if (vulnerabilityOptional.isPresent() && CollectionUtils.isNotEmpty(artifactList)) {
            Vulnerability vulnerability = vulnerabilityOptional.get();
            vulnerabilityGraphForm.setId(vulnerability.getUuid());
            vulnerabilityGraphForm.setName("漏洞编号");
            vulnerabilityGraphForm.setLabel(vulnerability.getUuid());
            vulnerabilityGraphForm.setCurrency(SeverityTypeEnum.queryTitleByType(vulnerability.getHighestSeverityText()));
            vulnerabilityGraphForm.setVariableName(vulnerability.getVersionEndExcluding());
            List<VulnerabilityGraphForm> storageGraphList = Lists.newArrayList();
            VulnerabilityGraphForm storageGraph, artifactGraph;
            Map<String, List<Artifact>> repositoryIdMap;
            List<VulnerabilityGraphForm> repositoryGraphList, artifactGraphList;
            String artifactName;
            VulnerabilityGraphForm repositoryGraph;
            Repository repository;
            boolean isDockerLayout;
            //存储空间分组
            Map<String, List<Artifact>> storageIdMap = artifactList.stream().collect(Collectors.groupingBy(Artifact::getStorageId, Collectors.toCollection(LinkedList::new)));
            for (Map.Entry<String, List<Artifact>> storageEntry : storageIdMap.entrySet()) {
                storageGraph = VulnerabilityGraphForm.builder().id(storageEntry.getKey()).name("所属空间").label(storageEntry.getKey()).rate(BigDecimal.valueOf(1)).build();
                //仓库分组
                repositoryIdMap = storageEntry.getValue().stream().collect(Collectors.groupingBy(Artifact::getRepositoryId, Collectors.toCollection(LinkedList::new)));
                repositoryGraphList = Lists.newArrayList();
                for (Map.Entry<String, List<Artifact>> repositoryEntry : repositoryIdMap.entrySet()) {
                    repository = configurationManager.getRepository(storageEntry.getKey(), repositoryEntry.getKey());
                    isDockerLayout = Objects.nonNull(repository) && DockerLayoutProvider.ALIAS.equalsIgnoreCase(repository.getLayout());
                    repositoryGraph = VulnerabilityGraphForm.builder().id(String.format("%s-%s", storageEntry.getKey(), repositoryEntry.getKey())).name("所属仓库").label(repositoryEntry.getKey()).rate(BigDecimal.valueOf(1)).build();
                    artifactGraphList = Lists.newArrayList();
                    for (Artifact artifact : repositoryEntry.getValue()) {
                        artifactName = artifact.getArtifactPath();
                        if (isDockerLayout) {
                            artifactName = artifactComponent.getDockerImage(artifact.getArtifactPath());
                        }
                        artifactGraph = VulnerabilityGraphForm.builder().id(artifact.getUuid()).name("制品信息").label(artifactName).variableName("").variableValue(BigDecimal.valueOf(artifact.getDownloadCount())).variableUp(false)
                                .count(artifact.getDownloadCount()).currency("").rate(BigDecimal.valueOf(1)).status("B").build();
                        artifactGraphList.add(artifactGraph);
                    }
                    repositoryGraph.setChildren(artifactGraphList);
                    repositoryGraphList.add(repositoryGraph);
                }
                storageGraph.setChildren(repositoryGraphList);
                storageGraphList.add(storageGraph);
            }
            vulnerabilityGraphForm.setChildren(storageGraphList);
        }
        return vulnerabilityGraphForm;
    }


    @Override
    public RepositoryVulnerabilityStatisticsForm repositoryVulnerabilityStatistics(String storageId, String repositoryId) {
        List<String> storageIdAndRepositoryIdList = Collections.singletonList(String.format("%s-%s", storageId, repositoryId));
        String layout = "";
        Repository repository = configurationManager.getRepository(storageId, repositoryId);
        layout = repository.getLayout();
        boolean isGroupRepository = RepositoryTypeEnum.GROUP.getType().equals(repository.getType());
        if (isGroupRepository) {
            storageIdAndRepositoryIdList = getGroupStorageIdAndRepositoryId(repository);
        }
        Long artifactCount = artifactRepository.countByStorageIdAndRepositoryId(storageIdAndRepositoryIdList, layout);
        Map<String, Long> map = artifactRepository.countArtifactByStorageIdAndRepositoryId(storageIdAndRepositoryIdList);
        Long downloadCount = map.getOrDefault(Properties.DOWNLOAD_COUNT, 0L);
        Long dependencyCount = map.getOrDefault(Properties.DEPENDENCY_COUNT, 0L);
        Long vulnerabilityCount = vulnerabilityRepository.countByStorageIdAndRepositoryId(storageIdAndRepositoryIdList);
        RepositoryDto repositoryDto = null;
        Set<String> vulnerabilityWhites = Sets.newLinkedHashSet(), vulnerabilityBlacks = Sets.newLinkedHashSet();
        List<RepositoryInfo> repositoryInfoList = getRepositoryInfo(repository);
        for (RepositoryInfo repositoryInfo : repositoryInfoList) {
            repositoryDto = configurationManagementService.getMutableConfigurationClone().getStorage(repositoryInfo.getStorageId()).getRepository(repositoryInfo.getRepositoryId());
            if (Objects.nonNull(repositoryDto)) {
                if (CollectionUtils.isNotEmpty(repositoryDto.getVulnerabilityWhites())) {
                    vulnerabilityWhites.addAll(repositoryDto.getVulnerabilityWhites());
                }
                if (CollectionUtils.isNotEmpty(repositoryDto.getVulnerabilityBlacks())) {
                    vulnerabilityBlacks.addAll(repositoryDto.getVulnerabilityBlacks());
                }
            }
        }
        Long artifactBytes = artifactRepository.artifactsBytesStatistics(storageIdAndRepositoryIdList);
        return RepositoryVulnerabilityStatisticsForm.builder().artifactCount(artifactCount).downloadCount(downloadCount).dependencyCount(dependencyCount)
                .vulnerabilityCount(vulnerabilityCount).whites(vulnerabilityWhites).blacks(vulnerabilityBlacks).artifactBytes(artifactBytes).build();
    }

    @Override
    public void handlerStoragesAndRepositories() {
        List<Vulnerability> vulnerabilityList = vulnerabilityRepository.queryVulnerabilityList();
        handlerStoragesAndRepositoriesByVulnerabilityList(vulnerabilityList);
    }

    @Override
    public void handlerStoragesAndRepositoriesByVulnerabilityList(List<Vulnerability> vulnerabilityList) {
        if (CollectionUtils.isNotEmpty(vulnerabilityList)) {
            List<Artifact> artifactList;
            Set<String> storages, storagesAndRepositories;
            for (Vulnerability vulnerability : vulnerabilityList) {
                try {
                    artifactList = vulnerabilityRepository.queryArtifactByVulnerabilityVertexIdAndVulnerabilityId(vulnerability.getNativeId(), vulnerability.getUuid());
                    if (CollectionUtils.isNotEmpty(artifactList)) {
                        storages = artifactList.stream().map(Artifact::getStorageId).collect(Collectors.toSet());
                        storagesAndRepositories = artifactList.stream().map(item -> String.format("%s-%s", item.getStorageId(), item.getRepositoryId())).collect(Collectors.toCollection(LinkedHashSet::new));
                        vulnerability.setStorages(storages);
                        vulnerability.setStoragesAndRepositories(storagesAndRepositories);
                        log.info("Vulnerability [{}] [{}]", vulnerability.getUuid(), vulnerability.getStoragesAndRepositories());
                        vulnerabilityService.saveOrUpdateVulnerability(vulnerability, true);
                    } else {
                        vulnerabilityRepository.delete(vulnerability);
                    }
                } catch (Exception ex) {
                    log.error("handlerStoragesAndRepositories：{}，error：{}", JSONObject.toJSONString(vulnerability), ExceptionUtils.getStackTrace(ex));
                }
            }
        }
    }

    @Override
    public void handlerStoragesAndRepositoriesByVulnerabilityList(String storageId, String repositoryId, List<Vulnerability> vulnerabilityList) {
        if (CollectionUtils.isNotEmpty(vulnerabilityList)) {
            long count = 0;
            Set<String> storages, storagesAndRepositories;
            for (Vulnerability vulnerability : vulnerabilityList) {
                try {
                    count = vulnerabilityRepository.countRepositoryArtifactByVulnerability(vulnerability.getNativeId(), vulnerability.getUuid(), storageId, repositoryId);
                    if (count <= 0) {
                        storages = vulnerability.getStorages();
                        storages.add(storageId);
                        storagesAndRepositories = vulnerability.getStoragesAndRepositories();
                        storagesAndRepositories.add(String.format("%s-%s", storageId, repositoryId));
                        vulnerability.setStorages(storages);
                        vulnerability.setStoragesAndRepositories(storagesAndRepositories);
                        log.info("Vulnerability [{}] [{}]", vulnerability.getUuid(), vulnerability.getStoragesAndRepositories());
                        vulnerabilityService.saveOrUpdateVulnerability(vulnerability, true);
                    }
                } catch (Exception ex) {
                    log.error("handlerStoragesAndRepositories：{}，error：{}", JSONObject.toJSONString(vulnerability), ExceptionUtils.getStackTrace(ex));
                }
            }
        }
    }

    /**
     * 处理数据、发送邮件
     *
     * @param levels        漏洞等级列表
     * @param storageIdList 存储空间集合
     * @param email         接收邮箱
     */
    private void handlerDataAndSendEmail(Set<String> levels, List<String> storageIdList, String email) {
        try {
            if (StringUtils.isBlank(email)) {
                return;
            }
            String filePath = tempPath + File.separator + UUID.randomUUID() + ".xlsx";
            FileUtil.mkdir(tempPath);
            File file = FileUtil.file(filePath);
            FileOutputStream fileOutputStream = new FileOutputStream(file);
            try {
                List<VulnerabilityArtifactDomain> artifactList = artifactRepository.findMatchingHasVulnerabilityByStorageIdsAndLevels(storageIdList, levels);
                InputStream template = this.getClass().getResourceAsStream("/template/vulnerabilityStorageTemplate.xlsx");
                try (ExcelWriter excelWriter = EasyExcel.write(fileOutputStream).withTemplate(template).build()) {
                    WriteSheet writeSheet = EasyExcel.writerSheet().build();
                    FillConfig fillConfig = FillConfig.builder().build();
                    if (CollectionUtils.isNotEmpty(artifactList)) {
                        SimpleDateFormat df = DateUtil.newSimpleFormat("yyyy-MM-dd HH:mm:ss");
                        List<List<VulnerabilityArtifactDomain>> list = com.google.common.collect.Lists.partition(artifactList, 200);
                        for (List<VulnerabilityArtifactDomain> itemList : list) {
                            // 放入数据
                            excelWriter.fill(itemList.stream().map(artifact -> {
                                ArtifactVo artifactVo = ArtifactVo.builder().build();
                                BeanUtils.copyProperties(artifact, artifactVo);
                                if (artifact.getCreated() != null) {
                                    String createdTime = DateUtil.format(Date.from(artifact.getCreated().atZone(ZoneId.of("Asia/Shanghai")).toOffsetDateTime().toInstant()), df);
                                    artifactVo.setCreatedTime(createdTime);
                                }
                                if (artifact.getLastUsed() != null) {
                                    String lastUsedTime = DateUtil.format(Date.from(artifact.getLastUsed().atZone(ZoneId.of("Asia/Shanghai")).toOffsetDateTime().toInstant()), df);
                                    artifactVo.setLastUsedTime(lastUsedTime);
                                }
                                artifactVo.setSha(artifact.getChecksums().get("SHA-1"));
                                artifactVo.setSize(FileSizeConvertUtils.convert(artifact.getSizeInBytes()));
                                artifactVo.setMd5(artifact.getChecksums().get("MD5"));
                                artifactVo.setName(artifact.getUuid().substring(artifact.getUuid().lastIndexOf("/") + 1));
                                return artifactVo;
                            }).collect(Collectors.toList()), fillConfig, writeSheet);
                        }
                    } else {
                        excelWriter.fill(Collections.emptyList(), fillConfig, writeSheet);
                    }
                    excelWriter.finish();
                    sendMail.sendHtmlMail(MailRequest.builder().filePath(filePath).sendTo(email).subject("漏洞信息通知").text("此邮件为漏洞信息通知邮件，漏洞详情见附件").build());
                }
            } finally {
                fileOutputStream.close();
                FileUtil.del(file);
            }
        } catch (Exception ex) {
            log.error("发送漏洞邮件错误：{}", ExceptionUtils.getStackTrace(ex));
        }
    }

    private List<String> getStorageIdAndRepositoryId(String storageId, String repositoryId) {
        List<String> storageIdAndRepositoryIdList = null;
        if (StringUtils.isNotBlank(storageId) && StringUtils.isNotBlank(repositoryId)) {
            storageIdAndRepositoryIdList = Collections.singletonList(String.format("%s-%s", storageId, repositoryId));
            Repository repository = configurationManager.getRepository(storageId, repositoryId);
            boolean isGroupRepository = RepositoryTypeEnum.GROUP.getType().equals(repository.getType());
            if (isGroupRepository) {
                storageIdAndRepositoryIdList = getGroupStorageIdAndRepositoryId(repository);
            }
        }
        return storageIdAndRepositoryIdList;
    }

    private List<String> getGroupStorageIdAndRepositoryId(Repository repository) {
        List<String> storageIdAndRepositoryIdList = Lists.newArrayList();
        List<String> storageAndRepositoryIdList = com.google.common.collect.Lists.newArrayList();
        configurationManager.resolveGroupRepository(repository, storageAndRepositoryIdList);
        for (String storageAndRepositoryId : storageAndRepositoryIdList) {
            String sId = ConfigurationUtils.getStorageId(repository.getStorage().getId(), storageAndRepositoryId);
            String rId = ConfigurationUtils.getRepositoryId(storageAndRepositoryId);
            Repository subRepository = configurationManagementService.getConfiguration().getRepository(sId, rId);
            if (!subRepository.isInService()) {
                continue;
            }
            if (!subRepository.isAllowsDirectoryBrowsing()) {
                continue;
            }
            storageIdAndRepositoryIdList.add(subRepository.getStorage().getId() + "-" + subRepository.getId());
        }
        return storageIdAndRepositoryIdList;
    }

    private List<RepositoryInfo> getRepositoryInfo(Repository repository) {
        List<RepositoryInfo> storageIdAndRepositoryIdList = Lists.newArrayList();
        if (!repository.isGroupRepository()) {
            storageIdAndRepositoryIdList.add(RepositoryInfo.builder().storageId(repository.getStorage().getId()).repositoryId(repository.getId()).build());
        } else {
            List<String> storageAndRepositoryIdList = com.google.common.collect.Lists.newArrayList();
            configurationManager.resolveGroupRepository(repository, storageAndRepositoryIdList);
            for (String storageAndRepositoryId : storageAndRepositoryIdList) {
                String sId = ConfigurationUtils.getStorageId(repository.getStorage().getId(), storageAndRepositoryId);
                String rId = ConfigurationUtils.getRepositoryId(storageAndRepositoryId);
                Repository subRepository = configurationManagementService.getConfiguration().getRepository(sId, rId);
                if (!subRepository.isInService()) {
                    continue;
                }
                if (!subRepository.isAllowsDirectoryBrowsing()) {
                    continue;
                }
                storageIdAndRepositoryIdList.add(RepositoryInfo.builder().storageId(subRepository.getStorage().getId()).repositoryId(subRepository.getId()).build());
            }
        }
        return storageIdAndRepositoryIdList;
    }
}
