/*
 * Folib - [新一代AI制品仓库]
 * Copyright (C) 2025 bocloud.com.cn <folib@beyondcent.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * 本程序是自由软件：您可依据GNU通用公共许可证（GPL-3.0+）条款重新发布和修改，
 * 但禁止任何形式的商业售卖行为（包括但不限于：直接销售、捆绑销售、云服务商用）。
 *
 * This program is distributed WITHOUT ANY WARRANTY.
 * Commercial sale of this software is expressly prohibited.
 *
 * For license details, see: https://www.gnu.org/licenses/gpl-3.0.html
 * 商业授权咨询请联系：folib@beyondcent.com
 */
package com.folib.repositories;

import cn.hutool.core.date.DateTime;
import cn.hutool.core.date.DateUtil;
import com.folib.artifact.coordinates.GenericCoordinates;
import com.folib.components.DistributedLockComponent;
import com.folib.configuration.ConfigurationManager;
import com.folib.constant.GlobalConstants;
import com.folib.db.schema.Edges;
import com.folib.db.schema.Properties;
import com.folib.db.schema.Vertices;
import com.folib.domain.Artifact;
import com.folib.domain.Vulnerability;
import com.folib.enums.VulnerabilityPlatformEnum;
import com.folib.gremlin.adapters.ArtifactAdapter;
import com.folib.gremlin.adapters.VulnerabilityAdapter;
import com.folib.gremlin.dsl.EntityTraversal;
import com.folib.gremlin.dsl.EntityTraversalUtils;
import com.folib.gremlin.repositories.GremlinVertexRepository;
import com.folib.providers.io.RepositoryPath;
import com.folib.util.CommonUtils;
import com.folib.util.LocalDateTimeInstance;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.tinkerpop.gremlin.process.traversal.P;
import org.apache.tinkerpop.gremlin.structure.Vertex;
import org.janusgraph.core.JanusGraph;
import org.janusgraph.core.attribute.Text;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Repository;

import jakarta.inject.Inject;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * 漏洞顶点图数据交互
 *
 * @author veadan
 * @date 2022/9/29
 **/
@Slf4j
@Repository
@Transactional
public class VulnerabilityRepository extends GremlinVertexRepository<Vulnerability> {

    @Inject
    VulnerabilityAdapter vulnerabilityAdapter;

    @Inject
    ArtifactAdapter artifactAdapter;

    @Inject
    ConfigurationManager configurationManager;

    @Inject
    JanusGraph janusGraph;

    @Inject
    DistributedLockComponent distributedLockComponent;

    @Override
    protected VulnerabilityAdapter adapter() {
        return vulnerabilityAdapter;
    }

    public Page<Vulnerability> queryVulnerabilityPage(Pageable pagination, String vulnerabilityId,
                                                      String storageId,
                                                      List<String> storageIdAndRepositoryIdList, Integer dateSearchType) {
        Long count = onlyVulnerabilityBuildEntityTraversal(vulnerabilityId, null, storageIdAndRepositoryIdList, dateSearchType).count().tryNext().orElse(0L);
        long low = pagination.getPageNumber() * pagination.getPageSize();
        long high = (pagination.getPageNumber() + 1) * pagination.getPageSize();
        List<Vulnerability> vulnerabilityList = onlyVulnerabilityBuildEntityTraversal(vulnerabilityId, null, storageIdAndRepositoryIdList, dateSearchType)
                .range(low, high)
                .map(vulnerabilityAdapter.fold()).toList();
        return new PageImpl<Vulnerability>(EntityTraversalUtils.reduceHierarchy(vulnerabilityList), pagination, count);
    }

    public List<Vulnerability> queryVulnerabilityList() {
        return onlyVulnerabilityBuildEntityTraversal(null, null, null, null)
                .map(vulnerabilityAdapter.fold()).toList();
    }

    public Long countByStorageIdAndRepositoryId(List<String> storageIdAndRepositoryIdList) {
        return onlyVulnerabilityBuildEntityTraversal("", null, storageIdAndRepositoryIdList, 0).count().tryNext().orElse(0L);
    }

    public List<Artifact> queryArtifactByVulnerabilityVertexIdAndVulnerabilityId(Long vertexId, String vulnerabilityId) {
        return g().V(vertexId).inE(Edges.ARTIFACT_HAS_VULNERABILITIES).has(Properties.VULNERABILITY_ID, vulnerabilityId).outV().map(artifactAdapter.baseFold(Optional.of(GenericCoordinates.class))).toList();
    }

    public Page<Vulnerability> queryVulnerabilityPageByArtifact(Pageable pagination, String artifactPath,
                                                                String searchKeyword) {
        Long count = commonBuildEntityTraversalByArtifact(artifactPath, searchKeyword).count().tryNext().orElse(0L);
        long low = pagination.getPageNumber() * pagination.getPageSize();
        long high = (pagination.getPageNumber() + 1) * pagination.getPageSize();
        List<Vulnerability> vulnerabilityList = commonBuildEntityTraversalByArtifact(artifactPath, searchKeyword)
                .range(low, high)
                .map(vulnerabilityAdapter.fold()).toList();
        return new PageImpl<Vulnerability>(EntityTraversalUtils.reduceHierarchy(vulnerabilityList), pagination, count);
    }

    private EntityTraversal<Vertex, Vertex> commonBuildEntityTraversalByArtifact(String artifactPath, String searchKeyword) {
        EntityTraversal<Vertex, Vertex> entityTraversal = g().V().hasLabel(Vertices.ARTIFACT)
                .has(Properties.UUID, artifactPath).outE(Edges.ARTIFACT_HAS_VULNERABILITIES).inV().hasLabel(Vertices.VULNERABILITY).has(Properties.CREATED, P.gt(0));
        if (StringUtils.isNotBlank(searchKeyword)) {
            entityTraversal = entityTraversal.has(Properties.UUID, Text.textContains(searchKeyword));
        }
        return entityTraversal;
    }

    public Page<Vulnerability> queryVulnerabilityPageByComponent(Pageable pagination, String componentUuid,
                                                                 String searchKeyword) {
        Long count = commonBuildEntityTraversalByComponent(componentUuid, searchKeyword).count().tryNext().orElse(0L);
        long low = pagination.getPageNumber() * pagination.getPageSize();
        long high = (pagination.getPageNumber() + 1) * pagination.getPageSize();
        List<Vulnerability> vulnerabilityList = commonBuildEntityTraversalByComponent(componentUuid, searchKeyword)
                .range(low, high)
                .map(vulnerabilityAdapter.fold()).toList();
        return new PageImpl<Vulnerability>(EntityTraversalUtils.reduceHierarchy(vulnerabilityList), pagination, count);
    }

    private EntityTraversal<Vertex, Vertex> commonBuildEntityTraversalByComponent(String componentUuid, String searchKeyword) {
        EntityTraversal<Vertex, Vertex> entityTraversal = g().V().hasLabel(Vertices.COMPONENT)
                .has(Properties.UUID, componentUuid).outE(Edges.COMPONENT_HAS_VULNERABILITIES).inV().hasLabel(Vertices.VULNERABILITY).has(Properties.CREATED, P.gt(0));
        if (StringUtils.isNotBlank(searchKeyword)) {
            entityTraversal = entityTraversal.has(Properties.UUID, Text.textContains(searchKeyword));
        }
        return entityTraversal;
    }

    private void handlerCommon(Vulnerability vulnerability, boolean replace) {
        Optional<Vulnerability> vulnerabilityOptional = this.findById(vulnerability.getUuid());
        boolean exist = vulnerabilityOptional.isPresent();
        if (exist) {
            //存在
            vulnerability.setNativeId(vulnerabilityOptional.get().getNativeId());
            vulnerability.setLastUpdated(LocalDateTimeInstance.now());
            if (!replace) {
                if (CollectionUtils.isNotEmpty(vulnerability.getStorages())) {
                    Set<String> storages = vulnerabilityOptional.get().getStorages();
                    if (CollectionUtils.isNotEmpty(storages)) {
                        storages.addAll(vulnerability.getStorages());
                        vulnerability.setStorages(storages);
                    }
                }
                if (CollectionUtils.isNotEmpty(vulnerability.getStoragesAndRepositories())) {
                    Set<String> storagesAndRepositories = vulnerabilityOptional.get().getStoragesAndRepositories();
                    if (CollectionUtils.isNotEmpty(storagesAndRepositories)) {
                        storagesAndRepositories.addAll(vulnerability.getStoragesAndRepositories());
                        vulnerability.setStoragesAndRepositories(storagesAndRepositories);
                    }
                }
            }
        } else {
            //不存在
            vulnerability.setCreated(LocalDateTimeInstance.now());
        }
    }

    public void saveOrUpdate(Vulnerability vulnerability, boolean replace) {
        if (distributedLockComponent.lock(vulnerability.getUuid(), GlobalConstants.WAIT_LOCK_TIME, TimeUnit.SECONDS)) {
            try {
                try {
                    handlerCommon(vulnerability, replace);
                    merge(vulnerability);
                } catch (Exception ex) {
                    if (CommonUtils.catchException(ex)) {
                        log.warn("Handle vulnerability [{}] catch error", vulnerability.getUuid());
                        return;
                    }
                    log.error("Handle vulnerability [{}] error [{}]", vulnerability.getUuid(), ExceptionUtils.getStackTrace(ex));
                    throw new RuntimeException(ex.getMessage());
                }
            } finally {
                distributedLockComponent.unLock(vulnerability.getUuid());
            }
        } else {
            log.warn("Handle vulnerability [{}] was not get lock", vulnerability.getUuid());
        }
    }

    @Async("asyncDeleteArtifactTaskExecutor")
    public void asyncHandlerVulnerabilityForArtifactDelete(RepositoryPath repositoryPath, Set<String> vulnerabilities) {
        handlerVulnerabilityForArtifactDelete(repositoryPath, vulnerabilities);
    }

    public void handlerVulnerabilityForArtifactDelete(RepositoryPath repositoryPath, Set<String> vulnerabilities) {
        if (CollectionUtils.isEmpty(vulnerabilities)) {
            return;
        }
        try {
            Thread.sleep(1000L);
        } catch (Exception ignore) {
        }
        String storageId = repositoryPath.getStorageId();
        String repositoryId = repositoryPath.getRepositoryId();
        long count;
        String item;
        for (String vulnerabilityId : vulnerabilities) {
            Optional<Vulnerability> vulnerabilityOptional = this.findById(vulnerabilityId);
            if (vulnerabilityOptional.isPresent()) {
                Vulnerability vulnerability = vulnerabilityOptional.get();
                count = countRepositoryArtifactByVulnerability(vulnerability.getNativeId(), vulnerability.getUuid(), "", "");
                if (count <= 0) {
                    //没有关联制品删除
                    log.info("Delete Vulnerability [{}] [{}]", vulnerability.getUuid(), vulnerability.getStoragesAndRepositories());
                    this.delete(vulnerability);
                    continue;
                }
                //查询该漏洞在仓库中是否还有关联制品
                count = countRepositoryArtifactByVulnerability(vulnerability.getNativeId(), vulnerability.getUuid(), storageId, repositoryId);
                if (count > 0) {
                    continue;
                }
                item = String.format("%s-%s", storageId, repositoryId);
                if (!vulnerability.getStoragesAndRepositories().contains(item)) {
                    continue;
                }
                vulnerability.getStoragesAndRepositories().remove(item);
                vulnerability.getStorages().remove(storageId);
                log.info("Vulnerability [{}] [{}]", vulnerability.getUuid(), vulnerability.getStoragesAndRepositories());
                saveOrUpdate(vulnerability, true);
            }
        }
    }

    public long countRepositoryArtifactByVulnerability(Long vertexId, String vulnerabilityId, String storageId, String repositoryId) {
        if (StringUtils.isNotBlank(storageId) && StringUtils.isNotBlank(repositoryId)) {
            return g().V(vertexId).inE(Edges.ARTIFACT_HAS_VULNERABILITIES).has(Properties.VULNERABILITY_ID, vulnerabilityId).outV().hasLabel(Vertices.ARTIFACT).has(Properties.STORAGE_ID, storageId).has(Properties.REPOSITORY_ID, repositoryId).count().tryNext().orElse(0L);
        }
        return g().V(vertexId).inE(Edges.ARTIFACT_HAS_VULNERABILITIES).has(Properties.VULNERABILITY_ID, vulnerabilityId).outV().hasLabel(Vertices.ARTIFACT).count().tryNext().orElse(0L);
    }

    /**
     * 构建公共图查询
     *
     * @param vulnerabilityId              漏洞id
     * @param storageId                    存储空间
     * @param storageIdAndRepositoryIdList 存储空间和仓库id
     * @param dateSearchType               日期搜索类型
     * @return 公共图查询
     */
    private EntityTraversal<Vertex, Vertex> onlyVulnerabilityBuildEntityTraversal(String vulnerabilityId, String storageId, List<String> storageIdAndRepositoryIdList, Integer dateSearchType) {
        EntityTraversal<Vertex, Vertex> entityTraversal = g().V().hasLabel(Vertices.VULNERABILITY).has(Properties.VULNERABILITY_PLATFORM_NAME, P.within(VulnerabilityPlatformEnum.values())).has(Properties.CREATED, P.gt(0));
        if (StringUtils.isNotBlank(vulnerabilityId)) {
            entityTraversal = entityTraversal.has(Properties.UUID, vulnerabilityId);
        }
        if (StringUtils.isNotBlank(storageId)) {
            entityTraversal = entityTraversal.has(Properties.STORAGES, storageId);
        }
        if (CollectionUtils.isNotEmpty(storageIdAndRepositoryIdList)) {
            entityTraversal = entityTraversal.has(Properties.STORAGES_AND_REPOSITORIES, P.within(storageIdAndRepositoryIdList));
        }
        if (Objects.nonNull(dateSearchType) && dateSearchType > 0) {
            Long begin = 0L, end = 0L;
            DateTime beginDateTime = null;
            if (dateSearchType == 1) {
                beginDateTime = DateUtil.parseDate(DateUtil.formatDate(DateUtil.lastWeek()));
            } else if (dateSearchType == 2) {
                beginDateTime = DateUtil.parseDate(DateUtil.formatDate(DateUtil.lastMonth()));
            } else if (dateSearchType == 3) {
                beginDateTime = DateUtil.parseDate(DateUtil.formatDate(DateUtil.offsetMonth(DateUtil.date(), -3)));
            } else if (dateSearchType == 4) {
                beginDateTime = DateUtil.parseDate(DateUtil.formatDate(DateUtil.offsetMonth(DateUtil.date(), -6)));
            }
            if (Objects.nonNull(beginDateTime)) {
                LocalDateTime beginLocalDateTime = EntityTraversalUtils.toLocalDateTime(beginDateTime);
                LocalDateTime endLocalDateTime = EntityTraversalUtils.toLocalDateTime(DateUtil.date());
                begin = EntityTraversalUtils.toLong(beginLocalDateTime);
                end = EntityTraversalUtils.toLong(endLocalDateTime);
                entityTraversal = entityTraversal.has(Properties.CREATED, P.between(begin, end));
            }
        }
        return entityTraversal;
    }
}

//@Repository
//interface VulnerabilityQueries
//        extends org.springframework.data.repository.Repository<Vulnerability, String> {
//
//}